import { Component, OnInit } from '@angular/core';
import { Field } from '../../models/field.interface';
import { FieldConfig } from '../../models/field-config.interface';
import { FormGroup, FormArray } from '@angular/forms';
import { Camera, CameraOptions } from '@ionic-native/camera/ngx';
import { ModalController, PopoverController } from '@ionic/angular';
import { ImageViewerModalComponent } from '../image-viewer-modal/image-viewer-modal.component';
import { widgetKeys } from '../../object-keys-constants';
import { FormDataDistributionService } from '../../form-data-distribution.service';
import { Constants } from '../../../constants/constants';
import { ModalsService } from '../../../sharedServices/modals.service';
import { EllipsePopoverComponent } from '../../../sharedComponents/ellipse-popover/ellipse-popover.component';
import { FormModuleconstants } from '../../form-module-constants';
import { CommonService } from '../../../sharedServices/commonServices/common.service';
import { WebView } from '@ionic-native/ionic-webview/ngx';
import { File } from '@ionic-native/file/ngx';
import { Base64ToGallery } from '@ionic-native/base64-to-gallery/ngx';
import { FormDrawingComponent } from '../form-drawing/form-drawing.component';
import { ApiUrls } from 'src/app/constants/api-urls';
import { RestApiService } from 'src/app/sharedServices/rest-api.service';
import { ToastService } from 'src/app/sharedServices/toast.service';
import { LoadingService } from 'src/app/sharedServices/loading.service';
import * as watermark from 'watermarkjs';
import { GeoLocationService } from '../../../sharedServices/geo-location.service';
import * as exif from 'exif-js';
import {TagValues, IExifElement, IExif, dump, insert } from 'piexif-ts';

@Component({
  selector: 'form-camera',
  templateUrl: './form-camera.component.html',
  styleUrls: ['./form-camera.component.scss'],
})
export class FormCameraComponent implements Field, OnInit {

  nullValue = Constants.nullValue;
  config: FieldConfig;
  group: FormGroup;
  imageCaptured: any;
  widgetKey: any;
  historyView: boolean;
  expendedHeaderId: any;
  derivedFields: any;
  derivedFieldsCopy: any;
  isDerivedField: boolean = false;
  bOSubscribe: any;
  data: any;
  cameraSource = this.camera.PictureSourceType.CAMERA;
  gallerySourc = this.camera.PictureSourceType.PHOTOLIBRARY;
  tableWidgetId: any;
  tableWidgetIndex: any;
  isTable: boolean;
  allMetaData: any;
  constructor(
    private camera: Camera,
    private modalController: ModalController,
    private formDataDistributionService: FormDataDistributionService,
    private modalsService: ModalsService,
    private commonService: CommonService,
    private webView: WebView,
    private file: File,
    private base64ToGallery: Base64ToGallery,
    private popoverController: PopoverController,
    private restApiService: RestApiService,
    private toastService: ToastService,
    private loader: LoadingService,
    private geoLocationService: GeoLocationService
  ) {
    this.widgetKey = widgetKeys.keys;
  }

  async openImage(img) {
    const modal = await this.modalController.create({
      component: ImageViewerModalComponent,
      componentProps: {
        imgData: img,
        Header: this.config[this.widgetKey.label],
        footer: FormModuleconstants.retake,
        change: this.retakeImage.bind(this),
        annotated: this.imageAnnotation.bind(this),
        delete: this.deleteImage.bind(this),
        fieldid: this.config[widgetKeys.keys._id],
        edit: true,
        historyView: this.historyView
      }
    });
    modal.present();
  }
  imageAnnotation(img) {
    const newImg = img.replace('png', 'jpeg');
    this.watermarkImage(newImg);
  }

  // this is the last place for image process. 

 
  watermarkImage(img) {
    this.geoLocationService.getLatLong().then((resp) => {
      // geo tagging start 
      this.imageProcessAfterGettingGPsResponse(resp, img, 1);
    }).catch((error) => {
      this.toastService.showToast(Constants.unableToGetLocation);
      const obj =  {coords: {latitude: 'NA', longitude: 'NA'}};
      this.imageProcessAfterGettingGPsResponse(obj, img, 0);
    //  this.toastService.showToast('Geo tag added successfully on top of image');
    });
  }

  imageProcessAfterGettingGPsResponse(resp, img, GpsStatus) {
    try {
      if (this.allMetaData['formatLat'] && this.allMetaData['formatLong']) {
        this.allMetaData['formatLat'] = resp.coords.latitude;
        this.allMetaData['formatLong'] = resp.coords.longitude;
      }
      // // update geo tag details into image
      // const zeroth: IExifElement = {};
      // const exifRef: IExifElement = {};
      // const gps: IExifElement = {};
      // zeroth[TagValues.ImageIFD.Make] = 'Make';
      // zeroth[TagValues.ImageIFD.XResolution] = [777, 1];
      // zeroth[TagValues.ImageIFD.YResolution] = [777, 1];
      // zeroth[TagValues.ImageIFD.Software] = 'Piexifjs';
      // exifRef[TagValues.ExifIFD.DateTimeOriginal] = '2010:10:10 10:10:10';
      // exifRef[TagValues.ExifIFD.LensMake] = 'LensMake';
      // exifRef[TagValues.ExifIFD.Sharpness] = 777;
      // exifRef[TagValues.ExifIFD.LensSpecification] = [[1, 1], [1, 1], [1, 1], [1, 1]];
      // gps[TagValues.GPSIFD.GPSVersionID] = [7, 7, 7, 7];
      // // gps[TagValues.GPSIFD.GPSLongitude] = 78.890;
      // // gps[TagValues.GPSIFD.GPSLatitude] = 17.890;
      // const   exifObj: IExif = {'0th': zeroth, 'Exif': exifRef, 'GPS': gps};
      // const exifStr = dump(exifObj);
      // console.log("loveee");
      // const newImg = img.replace('png', 'jpeg');
      // console.log(newImg);
     
      // const exifImage = insert(exifStr, newImg);
      // // geo tagging end
       const today = new Date();
      const date = (today.getMonth() + 1) + '-' +  today.getDate() + '-' + today.getFullYear();
      const latLong = resp.coords.latitude + ',' + resp.coords.longitude;
      this.placWatermarkProcess(img, latLong + '   ' + date, resp.coords.latitude, resp.coords.longitude);
      if (GpsStatus) {
        this.toastService.showToast('Geo tag added successfully on top of image');
      }
    } catch (err) {
      console.log('eorrrrrrrr');
      console.log(err);
    }
  }
  placWatermarkProcess(img, text, lat, longi) {
    watermark([img])
    .image(watermark.text.lowerRight( text, '22px Arial', '#0099cc', 0.9))
      .then(image => {
        // const newImg = image.src.replace('png', 'jpeg');
        this.base64ToGallery.base64ToGallery(image.src, { prefix: '_img', mediaScanner: false }).then(
          res => {
            let mediaData: any = [];
            this.group.get(this.config[this.widgetKey._id]).setValue(this.webView.convertFileSrc(res));
            const imageName = res.substr(res.indexOf('_img'));
            const fullPath = res.substr(res.indexOf('/') + 1);
             // // update geo tag details into image
            const zeroth: IExifElement = {};
            const exifRef: IExifElement = {};
            const gps: IExifElement = {};
            zeroth[TagValues.ImageIFD.Make] = 'Make';
            zeroth[TagValues.ImageIFD.XResolution] = [777, 1];
            zeroth[TagValues.ImageIFD.YResolution] = [777, 1];
            zeroth[TagValues.ImageIFD.Software] = 'Piexifjs';
            exifRef[TagValues.ExifIFD.DateTimeOriginal] = '2010:10:10 10:10:10';
            exifRef[TagValues.ExifIFD.LensMake] = 'LensMake';
            exifRef[TagValues.ExifIFD.Sharpness] = 777;
            exifRef[TagValues.ExifIFD.LensSpecification] = [[1, 1], [1, 1], [1, 1], [1, 1]];
            gps[TagValues.GPSIFD.GPSVersionID] = [7, 7, 7, 7];
            // gps[TagValues.GPSIFD.GPSLongitude] = 78.890;
            // gps[TagValues.GPSIFD.GPSLatitude] = 17.890;
            const   exifObj: IExif = {'0th': zeroth, 'Exif': exifRef, 'GPS': gps};
            const exifStr = dump(exifObj);
            // const newImg1 = image.src.replace('png', 'jpeg');
            // console.log(newImg1);
            
            const reader = new FileReader();
            reader.onload = function(e) {
              const inserted = insert(exifStr, e.target['result']);
            };
            reader.readAsDataURL(image.src);

           // const exifImage = insert(exifStr, newImg1);
          // // geo tagging end
            mediaData = this.commonService.getMediaData() ? this.commonService.getMediaData() : [];
            const index = mediaData.findIndex(record => record.options.params.fieldId == this.config[this.widgetKey._id]);
            if (index > -1) {
              mediaData.splice(index, 1);
            }
            console.log(' final meta dataaaaa exif');
            console.log( this.allMetaData);
            const options = {
              fileKey: 'image',
              fileName: imageName,
              chunkedMode: false,
              mimeType: 'png',
              params: {
                fieldId: this.config[widgetKeys.keys._id]
              },
              exifData: this.allMetaData
            };
            mediaData.push({ options: options, path: fullPath });
            
            this.commonService.setMediaData(mediaData);
          },
          err => console.log('Error saving image to gallery ', err)
        );
      });
  }


  async drawImage(img) {
    const modal = await this.modalController.create({
      component: FormDrawingComponent,
      componentProps: {
        imgData: img,
        changeStatus: this.imageAnnotation.bind(this)
      }
    });
    modal.present();
  }
  loaded(e) {
    const that = this;
    exif.getData(e.target, function() {
        that.allMetaData = exif.getAllTags(this);
        let long = exif.getTag(e.target, 'GPSLongitude');
        let lat = exif.getTag(e.target, 'GPSLatitude');
        if (!long || !lat) {
          console.log('Unfortunately, I can\'t find GPS info for the picture');
          return;
        }
        console.log(that.allMetaData);
        console.log('hhhh');
        long = that.convertDegToDec(long);
        lat = that.convertDegToDec(lat);
        if (exif.getTag(this, 'GPSLongitudeRef') === 'W') { long = -1 * long; }
        if (exif.getTag(this, 'GPSLatitudeRef') === 'S') { lat = -1 * lat; }
        that.allMetaData['formatLat'] = lat;
        that.allMetaData['formatLong'] = long;
    });
  }
  convertDegToDec(arr) {
    return (arr[0].numerator + arr[1].numerator / 60 + (arr[2].numerator / arr[2].denominator) / 3600).toFixed(4);
  }

  cameraCapture(formcontrolNameRef: any, sourceTypeVal) {
    this.popoverController.dismiss()
    const options: CameraOptions = {
      quality: 20,
      destinationType: this.camera.DestinationType.FILE_URI,
      encodingType: this.camera.EncodingType.JPEG,
      mediaType: this.camera.MediaType.PICTURE,
      correctOrientation: true,
      sourceType: sourceTypeVal
    };
    let correctPath;
    let currentName;
    this.camera.getPicture(options).then((imageData) => {
      this.imageCaptured = imageData;
      correctPath = imageData.substr(0, imageData.lastIndexOf('/') + 1);
      if (sourceTypeVal === this.cameraSource) {
        currentName = imageData.substring(imageData.lastIndexOf('/') + 1);
        this.imageCaptured = this.imageCaptured.substring(8);

      } else {
        currentName = imageData.substring(imageData.lastIndexOf('/') + 1, imageData.lastIndexOf('?'));
        this.imageCaptured = this.imageCaptured.substring(8, this.imageCaptured.lastIndexOf('?'));
      }
      this.copyFileToLocalDir(correctPath, currentName, currentName, formcontrolNameRef);
    }, (err) => {
    });
  }

  copyFileToLocalDir(namePath, currentName, newFileName, formcontrolNameRef) {

    let mediaData: any = [];
    this.file.copyFile(namePath, currentName, this.file.dataDirectory, newFileName).then(success => {
      mediaData = this.commonService.getMediaData() ? this.commonService.getMediaData() : [];
      const index = mediaData.findIndex(record => record.options.params.fieldId == formcontrolNameRef);
      if (index > -1) {
        mediaData.splice(index, 1);
      }
      console.log('new allmete data');
      console.log(this.allMetaData);
      const options = {
        fileKey: 'image',
        fileName: currentName,
        chunkedMode: false,
        mimeType: 'JPEG',
        params: {
          fieldId: this.config[widgetKeys.keys._id]
        },
        exifData: this.allMetaData
      };
      mediaData.push({ options: options, path: this.imageCaptured });
      // console.log(this.webView.convertFileSrc(this.file.dataDirectory + currentName));
      // console.log(this.file.dataDirectory + currentName);
      this.drawImage(this.webView.convertFileSrc(this.file.dataDirectory + currentName));
      this.group.get(formcontrolNameRef).setValue(this.webView.convertFileSrc(this.file.dataDirectory + currentName));
      this.commonService.setMediaData(mediaData);
    }, error => {
      console.log(error);
    });
  }

  retakeImage(event) {
    this.cameraCapture(this.config[this.widgetKey._id], this.cameraSource);
  }
  deleteImage() {
    this.imageCaptured = this.nullValue;
    let mediaData: any = [];
    mediaData = this.commonService.getMediaData() ? this.commonService.getMediaData() : [];
    let index = mediaData.findIndex(record => record.options.params.fieldId == this.config[widgetKeys.keys._id]);
    if (index > -1) {
      mediaData.splice(index, 1);
    }
    this.group.get(this.config[widgetKeys.keys._id]).setValue("");
    this.commonService.setMediaData(mediaData);
  }

  get tableWidgetArray() {
    return this.group.get(this.tableWidgetId) as FormArray;
  }
  viewPreview() {
    if (this.historyView) {
      this.loader.present()
      let imgUrl = ApiUrls.getImageorVideo + "/" + this.commonService.getRecordId() + "/" + this.config[widgetKeys.keys._id]
      let url = ApiUrls.fetchImageOrVideoExists + "/" + this.commonService.getRecordId() + "/" + this.config[widgetKeys.keys._id]
      const headers = this.restApiService.getHeadersForGet();
      try {
        this.restApiService.getServiceProcess(url, headers).subscribe(res => {
                         if(this.loader.isLoading){ this.loader.dismiss(); }
         
         
          if (res['status'] == 204) {
            this.toastService.showToast(Constants.noDataFound)

          }
          else if (res['status'] == 200) {
            this.openImage(imgUrl)
          }
        })
      } catch (e) {
                       if(this.loader.isLoading){ this.loader.dismiss(); }
         
         
        this.openImage(url)
      }
    }
  }
  ngOnInit() {
    if (this.group.get(this.config[this.widgetKey._id]).value && (this.commonService.getWOData().recordStatus == Constants.statusValue["Reassigned"] || this.historyView)) {
      let imgUrl = ApiUrls.getImageorVideo + "/" + this.commonService.getRecordId() + "/" + this.config[widgetKeys.keys._id]
      this.group.get(this.config[this.widgetKey._id]).setValue(imgUrl?imgUrl:'');

    }else{
          let camValue = this.group.get(this.config[widgetKeys.keys._id]).value ? this.group.get(this.config[widgetKeys.keys._id]).value : '';
    this.group.get(this.config[widgetKeys.keys._id]).setValue(camValue);

    }
    this.bOSubscribe = this.formDataDistributionService.hederOpen.subscribe(expendedHeaderId => {
      this.expendedHeaderId = expendedHeaderId;
    });

  }

  ngOnDestroy() {
    if (this.bOSubscribe) {
      this.bOSubscribe.unsubscribe();
    }
  }

  getImage(event, id) {
    if (!this.historyView) {
      const componentProps = {
        popoverList: FormModuleconstants.cameraActionList,
      }
      const that = this;
      this.modalsService.openPopover(EllipsePopoverComponent, 'custom-ellipse-popover', componentProps, event, function (data) {
        if (data == FormModuleconstants.cameraActionList[0])
          that.cameraCapture(id, that.cameraSource);
        else if (data == FormModuleconstants.cameraActionList[1])
          that.cameraCapture(id, that.gallerySourc);
      })
    } else {
      // this.viewPreview()
    }
  }
}
